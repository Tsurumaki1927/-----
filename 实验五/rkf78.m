

% RKF78求解器 (直接移植提供的算法)
function [t, y, h_actual] = rkf78(odefun, tspan, y0, h0, tol)
    % RKF78方法实现
    % 输入:
    %   odefun - 微分方程函数句柄: dy/dt = f(t, y)
    %   tspan  - 时间区间 [t0, tf]
    %   y0     - 初始条件
    %   h0     - 初始步长
    %   tol    - 容差
    % 输出:
    %   t      - 时间点
    %   y      - 解向量
    %   h_actual - 实际使用的步长序列
    
    % 初始化
    t0 = tspan(1); tf = tspan(2);
    t = t0;
    y = y0(:);
    h = h0;
    h_actual = [];
    
    % RKF78系数
    c = [0; 2/27; 1/9; 1/6; 5/12; 1/2; 5/6; 1/6; 2/3; 1/3; 1; 0; 1];
    
    b7 = [41/840; 0; 0; 0; 0; 34/105; 9/35; 9/35; 9/280; 9/280; 41/840; 0; 0];
    b8 = [0; 0; 0; 0; 0; 34/105; 9/35; 9/35; 9/280; 9/280; 0; 41/840; 41/840];
    
    a = zeros(13,12);
    a(2,1) = 2/27;
    a(3,1:2) = [1/36, 1/12];
    a(4,1:3) = [1/24, 0, 1/8];
    a(5,1:4) = [5/12, 0, -25/16, 25/16];
    a(6,1:5) = [1/20, 0, 0, 1/4, 1/5];
    a(7,1:6) = [-25/108, 0, 0, 125/108, -65/27, 125/54];
    a(8,1:7) = [31/300, 0, 0, 0, 61/225, -2/9, 13/900];
    a(9,1:8) = [2, 0, 0, -53/6, 704/45, -107/9, 67/90, 3];
    a(10,1:9) = [-91/108, 0, 0, 23/108, -976/135, 311/54, -19/60, 17/6, -1/12];
    a(11,1:10) = [2383/4100, 0, 0, -341/164, 4496/1025, -301/82, 2133/4100, 45/82, 45/164, 18/41];
    a(12,1:11) = [3/205, 0, 0, 0, 0, -6/41, -3/205, -3/41, 3/41, 6/41, 0];
    a(13,1:12) = [-1777/4100, 0, 0, -341/164, 4496/1025, -289/82, 2193/4100, 51/82, 33/164, 12/41, 0, 1];
    
    % 主循环
    while t(end) < tf
        if t(end) + h > tf
            h = tf - t(end);
        end
        
        % 计算13个阶段的k值
        k = zeros(length(y0), 13);
        k(:,1) = h * odefun(t(end), y(:,end));
        
        for i = 2:13
            sum_ak = zeros(size(y0));
            for j = 1:(i-1)
                if a(i,j) ~= 0
                    sum_ak = sum_ak + a(i,j) * k(:,j);
                end
            end
            k(:,i) = h * odefun(t(end) + c(i)*h, y(:,end) + sum_ak);
        end
        
        % 计算7阶和8阶解
        y7 = y(:,end);
        y8 = y(:,end);
        
        for i = 1:13
            y7 = y7 + b7(i) * k(:,i);
            y8 = y8 + b8(i) * k(:,i);
        end
        
        % 估计误差
        error = norm(y8 - y7);
        
        % 步长控制
        if error <= tol || h < 1e-12
            % 步长接受
            t = [t, t(end) + h];
            y = [y, y8];
            h_actual = [h_actual, h];
            
            % 调整下一步步长
            if error > 0
                h = h * min(5, max(0.1, 0.9 * (tol/error)^(1/8)));
            else
                h = h * 5; % 无误差时增大步长
            end
        else
            % 步长拒绝，减小步长重试
            h = h * max(0.1, 0.9 * (tol/error)^(1/8));
        end
        
        % 防止步长过小或过大
        h = max(h, 1e-12);
        if t(end) + h > tf
            h = tf - t(end);
        end
    end
end
